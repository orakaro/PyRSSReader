<p>
A customer had a program which
performed some final I/O operations
as it exited.
Various C++ objects deleted files or flushed buffers as part of their
destructors.
The customer found that if their program was left running when
the user shut down Windows, then the files never got deleted,
and the buffers were never flushed.
On the other hand, if they inserted an artificial delay into the
shutdown procedure, so that it waited ten seconds after the program
exited before continuing with shutdown,
then the files did indeed get cleaned up and the buffers were indeed flushed.
The customer confirmed that the program did receive the
<code>WM_END&shy;SESSION</code> message,
but it appeared as if
all disk I/O issued within five seconds of shutdown never gets
committed to disk.
This would appear to be a serious bug in Windows.
</p>
<p>
Because, of course,
when you find a problem with your program,
<a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/02/10/10127054.aspx">
your first reaction</a>
should be
to assume that
you found a bug in Windows so blatant it should be affecting
every program on the planet,
and yet somehow this horrific data loss bug eluded not only
the entirety of the Windows QA team,
but also every software developer for the past twenty years
who had a program that saved data at shutdown.
</p>
<p>
Or the problem could be in your code.
</p>
<p>
The documentation for the
<a href="http://msdn.microsoft.com/library/aa376889">
<code>WM_END&shy;SESSION</code> message</a> says,
</p>
<blockquote class="q">
<dl>
<dt><i>wParam</i>
<dd>If the session is being ended,
this parameter is <b>TRUE</b>;
the session can end any time after all applications
have returned from processing this message.
</dl>
</blockquote>
<p>
What is much more likely to be happening is that when
the application receives the
<code>WM_END&shy;SESSION</code> message,
it posts a message to itself to initiate controlled shutdown.
After the program returns from the
<code>WM_END&shy;SESSION</code> message,
the message pump picks up the shutdown message and
it is at this point that the program starts cleaning up objects,
including running destructors and flushing buffers,
and then finally calling <code>Exit&shy;Process</code>.
</p>
<p>
In other words, the problem is not that the final I/O never
got committed to disk.
The problem is that the final I/O <i>was never issued by the program</i>.
Once your program returns from the
<code>WM_END&shy;SESSION</code> message,
Windows has the right to terminate it without further warning.
If your system shuts down quickly,
that termination may occur before your destructors manage to run at all.
</p>
<p>
You cannot rely on any code in your program running once you have
responded to the
<code>WM_END&shy;SESSION</code> message.
That message is your "final warning".
If you need to do cleanup operations before termination,
you need to do them <i>before</i> returning from the
<code>WM_END&shy;SESSION</code> message.
Because once you return from that message,
your process is living on borrowed time.
</p>
<div style="clear: both;"></div><img height="1" src="http://blogs.msdn.com/aggbug.aspx?PostID=10429232" width="1" />